using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CSharp;
using TechTalk.SpecFlow.Configuration;
using TechTalk.SpecFlow.Generator.Configuration;
using TechTalk.SpecFlow.Generator.Interfaces;
using TechTalk.SpecFlow.Generator.Project;
using TechTalk.SpecFlow.Generator.UnitTestConverter;
using TechTalk.SpecFlow.Generator.UnitTestProvider;
using TechTalk.SpecFlow.Parser;
using TechTalk.SpecFlow.Parser.SyntaxElements;
using TechTalk.SpecFlow.Utils;

namespace TechTalk.SpecFlow.Generator
{
    [Obsolete("Use ITestGeneratorFactory / ITestGenerator instead")]
    public class SpecFlowGenerator
    {
        private readonly SpecFlowProject project;

        public SpecFlowGenerator(SpecFlowProject project)
        {
            this.project = project;
        }

        public void GenerateCSharpTestFile(FeatureFileInput featureFile, TextWriter outputWriter)
        {
            var codeProvider = new CSharpCodeProvider();
            GenerateTestFile(featureFile, codeProvider, outputWriter);
        }

        private void GenerateTestFile(FeatureFileInput featureFile, CodeDomProvider codeProvider, TextWriter outputWriter)
        {
            using(var reader = new StreamReader(featureFile.GetFullPath(project.ProjectSettings)))
            {
                GenerateTestFile(featureFile, codeProvider, reader, outputWriter);
            }
        }


        public void GenerateTestFile(FeatureFileInput featureFile, CodeDomProvider codeProvider, TextReader inputReader, TextWriter outputWriter)
        {
            outputWriter = new IndentProcessingWriter(outputWriter);

            CodeDomHelper codeDomHelper = new CodeDomHelper(codeProvider);

            var codeNamespace = GenerateTestFileCode(featureFile, inputReader, codeProvider, codeDomHelper);
            var options = new CodeGeneratorOptions
                {
                    BracingStyle = "C"
                };

            AddSpecFlowHeader(codeProvider, outputWriter, codeDomHelper);
            codeProvider.GenerateCodeFromNamespace(codeNamespace, outputWriter, options);
            AddSpecFlowFooter(codeProvider, outputWriter, codeDomHelper);
            outputWriter.Flush();
        }

        public CodeNamespace GenerateTestFileCode(FeatureFileInput featureFile, TextReader inputReader, CodeDomProvider codeProvider, CodeDomHelper codeDomHelper)
        {
            string targetNamespace = GetTargetNamespace(featureFile);

            SpecFlowLangParser parser = new SpecFlowLangParser(project.Configuration.GeneratorConfiguration.FeatureLanguage);
            Feature feature = parser.Parse(inputReader, featureFile.GetFullPath(project.ProjectSettings));

            IUnitTestGeneratorProvider generatorProvider = ConfigurationServices.CreateInstance<IUnitTestGeneratorProvider>(project.Configuration.GeneratorConfiguration.GeneratorUnitTestProviderType);
            codeDomHelper.InjectIfRequired(generatorProvider);

            ISpecFlowUnitTestConverter testConverter = new SpecFlowUnitTestConverter(generatorProvider, codeDomHelper, project.Configuration.GeneratorConfiguration.AllowDebugGeneratedFiles, project.Configuration.GeneratorConfiguration.AllowRowTests);

            var codeNamespace = testConverter.GenerateUnitTestFixture(feature, null, targetNamespace);

            return codeNamespace;
        }

        private string GetTargetNamespace(FeatureFileInput featureFile)
        {
            if (!string.IsNullOrEmpty(featureFile.CustomNamespace))
                return featureFile.CustomNamespace;

            if (string.IsNullOrEmpty(project.ProjectSettings.DefaultNamespace))
                return null;

            string targetNamespace = project.ProjectSettings.DefaultNamespace;
            string projectFolder = project.ProjectSettings.ProjectFolder;
            string sourceFileFolder = Path.GetDirectoryName(featureFile.GetFullPath(project.ProjectSettings));
            if (sourceFileFolder.StartsWith(sourceFileFolder, StringComparison.InvariantCultureIgnoreCase))
            {
                string extraFolders = sourceFileFolder.Substring(projectFolder.Length);
                if (extraFolders.Length > 0)
                {
                    string[] parts = extraFolders.TrimStart('\\').Split('\\');
                    targetNamespace += "." + string.Join(".",
                                                 parts.Select(p => p.ToIdentifier()).ToArray());
                }
            }
            return targetNamespace;
        }

        private void AddSpecFlowHeader(CodeDomProvider codeProvider, TextWriter outputWriter, CodeDomHelper codeDomHelper)
        {
            var specFlowHeaderTemplate = @"------------------------------------------------------------------------------
 <auto-generated>
     This code was generated by SpecFlow (http://www.specflow.org/).
     SpecFlow Version:{0}
     Runtime Version:{1}

     Changes to this file may cause incorrect behavior and will be lost if
     the code is regenerated.
 </auto-generated>
------------------------------------------------------------------------------";

            var headerReader = new StringReader(string.Format(specFlowHeaderTemplate, 
                GetCurrentSpecFlowVersion(),
                Environment.Version
                ));

            string line;
            while ((line = headerReader.ReadLine()) != null)
            {
                codeProvider.GenerateCodeFromStatement(new CodeCommentStatement(line), outputWriter, null);
            }

            codeProvider.GenerateCodeFromStatement(codeDomHelper.GetStartRegionStatement("Designer generated code"), outputWriter, null);
        }

        private void AddSpecFlowFooter(CodeDomProvider codeProvider, TextWriter outputWriter, CodeDomHelper codeDomHelper)
        {
            codeProvider.GenerateCodeFromStatement(codeDomHelper.GetEndRegionStatement(), outputWriter, null);
        }

        public Version GetCurrentSpecFlowVersion()
        {
            return Assembly.GetExecutingAssembly().GetName().Version;
        }

        static private readonly Regex versionRe = new Regex(@"SpecFlow Version:\s*(?<ver>\d+\.\d+\.\d+\.\d+)");

        public Version GetGeneratedFileSpecFlowVersion(string filePath)
        {
            try
            {
                if (!File.Exists(filePath))
                    return null;

                using (var reader = new StreamReader(filePath))
                {
                    return GetGeneratedFileSpecFlowVersion(reader);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex);
                return null;
            }
        }

        public static Version GetGeneratedFileSpecFlowVersion(TextReader reader)
        {
            try
            {
                const int maxLinesToScan = 10;

                int lineNo = 0;
                string line;
                while ((line = reader.ReadLine()) != null && lineNo < maxLinesToScan)
                {
                    var match = versionRe.Match(line);
                    if (match.Success)
                        return new Version(match.Groups["ver"].Value);

                    lineNo++;
                }
                return null;
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex);
                return null;
            }
        }
    }
}